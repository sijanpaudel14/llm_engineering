\chapter{Python Concepts and Examples}

This chapter identifies and explains all Python language features, concepts, and programming patterns used throughout the multi-agent system. For each concept, we provide clear explanations, simple illustrative examples, and then demonstrate how they're applied in the actual system code.

\section{Object-Oriented Programming Concepts}

\subsection{Classes and Objects}

\paragraph{Concept Explanation}
Classes define blueprints for creating objects, encapsulating data (attributes) and behavior (methods). Objects are instances of classes that maintain their own state.

\paragraph{Simple Example}
\begin{lstlisting}[caption=Basic Class Concept]
class Dog:
    species = "Canis lupus"  # Class attribute
    
    def __init__(self, name, age):
        self.name = name      # Instance attribute
        self.age = age        # Instance attribute
    
    def bark(self):          # Instance method
        return f"{self.name} says woof!"

# Object creation and usage
my_dog = Dog("Rex", 3)
print(my_dog.bark())  # Rex says woof!
print(my_dog.species) # Canis lupus
\end{lstlisting}

\paragraph{System Implementation}
\begin{lstlisting}[caption=Agent Class Implementation]
class Agent:
    # Class attributes (shared across all instances)
    RED = '\033[31m'
    GREEN = '\033[32m'
    RESET = '\033[0m'
    
    # Instance attributes with type hints
    name: str = ""
    color: str = '\033[37m'
    
    def log(self, message):  # Instance method
        """Log messages with agent identification"""
        color_code = self.BG_BLACK + self.color
        message = f"[{self.name}] {message}"
        logging.info(color_code + message + self.RESET)

# Concrete implementation
class SpecialistAgent(Agent):
    name = "Specialist Agent"  # Override class attribute
    color = Agent.RED          # Reference parent class attribute
\end{lstlisting}

\paragraph{Key Points in System}
\begin{itemize}
\item \textbf{Class Attributes}: Color constants shared across all agents
\item \textbf{Instance Attributes}: Each agent has unique name and color
\item \textbf{Method Implementation}: log() provides common functionality
\item \textbf{Attribute Override}: Subclasses customize name and color
\end{itemize}

\subsection{Inheritance}

\paragraph{Concept Explanation}
Inheritance allows classes to inherit attributes and methods from parent classes, enabling code reuse and establishing "is-a" relationships.

\paragraph{Simple Example}
\begin{lstlisting}[caption=Basic Inheritance Example]
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        pass  # Abstract method to be overridden

class Dog(Animal):  # Dog inherits from Animal
    def speak(self):
        return f"{self.name} barks"

class Cat(Animal):  # Cat inherits from Animal  
    def speak(self):
        return f"{self.name} meows"

# Polymorphic usage
animals = [Dog("Rex"), Cat("Whiskers")]
for animal in animals:
    print(animal.speak())  # Calls appropriate subclass method
\end{lstlisting}

\paragraph{System Implementation}
\begin{lstlisting}[caption=Agent Inheritance Hierarchy]
class Agent:  # Base class
    def log(self, message):
        """Template method used by all subclasses"""
        color_code = self.BG_BLACK + self.color
        message = f"[{self.name}] {message}"
        logging.info(color_code + message + self.RESET)

class PlanningAgent(Agent):  # Inherits from Agent
    name = "Planning Agent"
    color = Agent.GREEN
    
    def __init__(self, collection):
        # Uses inherited log() method
        self.log("Planning Agent is initializing")
        self.scanner = ScannerAgent()
        self.ensemble = EnsembleAgent(collection)
        self.messenger = MessagingAgent()
        self.log("Planning Agent is ready")

class EnsembleAgent(Agent):  # Also inherits from Agent
    name = "Ensemble Agent"
    color = Agent.YELLOW
    
    def price(self, description: str) -> float:
        # Uses inherited log() method
        self.log("Running Ensemble Agent")
        # Custom logic here
        return predicted_price
\end{lstlisting}

\paragraph{Inheritance Benefits in System}
\begin{itemize}
\item \textbf{Code Reuse}: All agents get logging functionality for free
\item \textbf{Consistency}: Common interface across all agent types
\item \textbf{Maintainability}: Changes to Agent affect all subclasses
\item \textbf{Polymorphism}: Can treat all agents uniformly
\end{itemize}

\subsection{Composition}

\paragraph{Concept Explanation}
Composition is a "has-a" relationship where objects contain other objects as components, enabling complex behavior through combining simpler parts.

\paragraph{Simple Example}
\begin{lstlisting}[caption=Basic Composition Example]
class Engine:
    def __init__(self, horsepower):
        self.horsepower = horsepower
    
    def start(self):
        return "Engine started"

class Car:
    def __init__(self, make, engine):
        self.make = make
        self.engine = engine  # Car HAS-A Engine (composition)
    
    def start(self):
        return f"{self.make}: {self.engine.start()}"

# Usage
v8_engine = Engine(400)
muscle_car = Car("Mustang", v8_engine)
print(muscle_car.start())  # Mustang: Engine started
\end{lstlisting}

\paragraph{System Implementation}
\begin{lstlisting}[caption=EnsembleAgent Composition Pattern]
class EnsembleAgent(Agent):
    def __init__(self, collection):
        self.log("Initializing Ensemble Agent")
        
        # Composition: EnsembleAgent HAS-A these agents
        self.specialist = SpecialistAgent()      # HAS-A SpecialistAgent
        self.frontier = FrontierAgent(collection) # HAS-A FrontierAgent
        self.random_forest = RandomForestAgent() # HAS-A RandomForestAgent
        self.model = joblib.load('ensemble_model.pkl')  # HAS-A ML model
        
        self.log("Ensemble Agent is ready")

    def price(self, description: str) -> float:
        """Coordinates composed agents to make ensemble prediction"""
        # Delegate to composed agents
        specialist = self.specialist.price(description)
        frontier = self.frontier.price(description)
        random_forest = self.random_forest.price(description)
        
        # Combine their results
        X = pd.DataFrame({
            'Specialist': [specialist],
            'Frontier': [frontier],
            'RandomForest': [random_forest],
            'Min': [min(specialist, frontier, random_forest)],
            'Max': [max(specialist, frontier, random_forest)],
        })
        return max(0, self.model.predict(X)[0])
\end{lstlisting}

\paragraph{Composition Benefits in System}
\begin{itemize}
\item \textbf{Flexibility}: Can change components at runtime
\item \textbf{Modularity}: Each component has single responsibility
\item \textbf{Loose Coupling}: Components don't depend on each other
\item \textbf{Reusability}: Same components used in different contexts
\end{itemize}

\section{Modern Python Features}

\subsection{Type Annotations}

\paragraph{Concept Explanation}
Type annotations provide static type information for variables, function parameters, and return values, improving code documentation and enabling better IDE support.

\paragraph{Simple Example}
\begin{lstlisting}[caption=Type Annotation Examples]
from typing import List, Dict, Optional

def greet(name: str, age: int) -> str:
    """Function with typed parameters and return value"""
    return f"Hello {name}, you are {age} years old"

def process_scores(scores: List[float]) -> Dict[str, float]:
    """Function with complex type annotations"""
    return {
        'average': sum(scores) / len(scores),
        'max': max(scores),
        'min': min(scores)
    }

# Variable annotations
name: str = "Alice"
numbers: List[int] = [1, 2, 3, 4, 5]
user_data: Optional[Dict[str, str]] = None
\end{lstlisting}

\paragraph{System Implementation}
\begin{lstlisting}[caption=System Type Annotations]
from typing import List, Dict, Self, Optional

class ScrapedDeal:
    # Instance attributes with type annotations
    category: str
    title: str
    summary: str
    url: str
    details: str
    features: str

    @classmethod
    def fetch(cls, show_progress: bool = False) -> List[Self]:
        """Class method with modern Self type annotation"""
        deals = []
        for feed_url in feeds:
            feed = feedparser.parse(feed_url)
            for entry in feed.entries[:10]:
                deals.append(cls(entry))
        return deals

class FrontierAgent(Agent):
    def price(self, description: str) -> float:
        """Clear input and output types"""
        documents, prices = self.find_similars(description)
        # ... processing
        return result
        
    def find_similars(self, description: str) -> tuple[List[str], List[float]]:
        """Modern Python 3.9+ tuple syntax"""
        # ... implementation
        return documents, prices

class PlanningAgent(Agent):
    def plan(self, memory: List[str] = []) -> Optional[Opportunity]:
        """Optional return type indicates possible None"""
        selection = self.scanner.scan(memory=memory)
        if selection:
            # ... processing
            return best_opportunity
        return None
\end{lstlisting}

\paragraph{Type Annotation Benefits in System}
\begin{itemize}
\item \textbf{IDE Support}: Better autocomplete and error detection
\item \textbf{Documentation}: Types serve as inline documentation
\item \textbf{Maintainability}: Easier to understand interfaces
\item \textbf{Debugging}: Type checkers can catch errors early
\end{itemize}

\subsection{F-Strings (Formatted String Literals)}

\paragraph{Concept Explanation}
F-strings provide a readable and efficient way to format strings by embedding expressions directly inside string literals.

\paragraph{Simple Example}
\begin{lstlisting}[caption=F-String Examples]
name = "Alice"
age = 30
score = 87.5

# Basic f-string interpolation
greeting = f"Hello, {name}! You are {age} years old."

# Expressions inside f-strings
result = f"{name}'s score is {score:.1f}%, which is {'PASS' if score >= 60 else 'FAIL'}"

# Format specifications
price = 123.456
formatted = f"Price: ${price:.2f}"  # Price: $123.46

# Debugging with f-strings
x, y = 10, 20
debug_info = f"{x=}, {y=}, {x+y=}"  # x=10, y=20, x+y=30
\end{lstlisting}

\paragraph{System Implementation}
\begin{lstlisting}[caption=F-Strings in Agent System]
class Agent:
    def log(self, message):
        """F-string for agent identification"""
        color_code = self.BG_BLACK + self.color
        message = f"[{self.name}] {message}"  # F-string interpolation
        logging.info(color_code + message + self.RESET)

class EnsembleAgent(Agent):
    def price(self, description: str) -> float:
        self.log("Running Ensemble Agent - collaborating with specialist, frontier and random forest agents")
        # ... processing
        y = max(0, self.model.predict(X)[0])
        self.log(f"Ensemble Agent complete - returning ${y:.2f}")  # Currency formatting
        return y

class PlanningAgent(Agent):
    def plan(self, memory: List[str] = []) -> Optional[Opportunity]:
        # ... processing
        best = opportunities[0]
        # F-string with currency formatting
        self.log(f"Planning Agent has identified the best deal has discount ${best.discount:.2f}")
        return best if best.discount > self.DEAL_THRESHOLD else None

class MessagingAgent(Agent):
    def alert(self, opportunity: Opportunity):
        """Complex f-string with multiple expressions"""
        text = f"Deal Alert! Price=${opportunity.deal.price:.2f}, "
        text += f"Estimate=${opportunity.estimate:.2f}, "
        text += f"Discount=${opportunity.discount:.2f} :"
        text += opportunity.deal.product_description[:10]+'... '
        text += opportunity.deal.url
        # Send notification
\end{lstlisting}

\paragraph{F-String Advantages in System}
\begin{itemize}
\item \textbf{Readability}: Clear variable interpolation
\item \textbf{Performance}: Faster than .format() or \% formatting
\item \textbf{Flexibility}: Support for expressions and formatting specs
\item \textbf{Currency Display}: Consistent price formatting (.2f)
\end{itemize}

\subsection{List Comprehensions}

\paragraph{Concept Explanation}
List comprehensions provide a concise way to create lists by applying expressions to items in iterables, optionally filtering them with conditions.

\paragraph{Simple Example}
\begin{lstlisting}[caption=List Comprehension Examples]
# Basic list comprehension
numbers = [1, 2, 3, 4, 5]
squares = [x**2 for x in numbers]  # [1, 4, 9, 16, 25]

# With conditional filtering
even_squares = [x**2 for x in numbers if x % 2 == 0]  # [4, 16]

# With expression transformation
words = ["hello", "world", "python"]
lengths = [len(word) for word in words]  # [5, 5, 6]

# Nested comprehension
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [item for row in matrix for item in row]  # [1,2,3,4,5,6,7,8,9]

# Dictionary comprehension
word_lengths = {word: len(word) for word in words}  # {'hello': 5, 'world': 5, 'python': 6}
\end{lstlisting}

\paragraph{System Implementation}
\begin{lstlisting}[caption=List Comprehensions in Agent System]
class PlanningAgent(Agent):
    def plan(self, memory: List[str] = []) -> Optional[Opportunity]:
        selection = self.scanner.scan(memory=memory)
        if selection:
            # List comprehension to convert deals to opportunities
            opportunities = [self.run(deal) for deal in selection.deals[:5]]
            opportunities.sort(key=lambda opp: opp.discount, reverse=True)
            best = opportunities[0]
            return best if best.discount > self.DEAL_THRESHOLD else None
        return None

class FrontierAgent(Agent):
    def find_similars(self, description: str):
        vector = self.model.encode([description])
        results = self.collection.query(query_embeddings=vector.astype(float).tolist(), n_results=5)
        documents = results['documents'][0][:]
        # List comprehension to extract prices from metadata
        prices = [m['price'] for m in results['metadatas'][0][:]]
        return documents, prices

class ScannerAgent(Agent):
    def fetch_deals(self, memory) -> List[ScrapedDeal]:
        urls = [opp.deal.url for opp in memory]  # Extract URLs
        scraped = ScrapedDeal.fetch()
        # Filter deals not already in memory
        result = [scrape for scrape in scraped if scrape.url not in urls]
        return result
\end{lstlisting}

\paragraph{List Comprehension Benefits in System}
\begin{itemize}
\item \textbf{Conciseness}: Replace multi-line loops with single expressions
\item \textbf{Readability}: Clear intent for data transformation
\item \textbf{Performance}: Often faster than equivalent for loops
\item \textbf{Functional Style}: Encourages immutable data transformations
\end{itemize}

\section{Advanced Python Concepts}

\subsection{Decorators}

\paragraph{Concept Explanation}
Decorators are functions that modify or extend the behavior of other functions or classes without permanently modifying them.

\paragraph{Simple Example}
\begin{lstlisting}[caption=Decorator Examples]
def timing_decorator(func):
    """Decorator to measure function execution time"""
    import time
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.2f} seconds")
        return result
    return wrapper

@timing_decorator
def slow_function():
    import time
    time.sleep(1)
    return "Done"

# Usage
result = slow_function()  # Prints: slow_function took 1.00 seconds

# Class method decorator
class MyClass:
    @classmethod
    def create_from_string(cls, data: str):
        """Alternative constructor"""
        return cls(data.split(','))
    
    @staticmethod
    def utility_function(x, y):
        """Function that doesn't need class or instance"""
        return x + y
\end{lstlisting}

\paragraph{System Implementation}
\begin{lstlisting}[caption=Decorators in Agent System]
class ScrapedDeal:
    @classmethod  # Class method decorator
    def fetch(cls, show_progress: bool = False) -> List[Self]:
        """Alternative constructor for creating multiple deals"""
        deals = []
        feed_iter = tqdm(feeds) if show_progress else feeds
        for feed_url in feed_iter:
            feed = feedparser.parse(feed_url)
            for entry in feed.entries[:10]:
                deals.append(cls(entry))  # cls refers to ScrapedDeal
                time.sleep(0.5)
        return deals

# Potential decorator for logging (not implemented in original)
def log_execution(func):
    """Decorator to log method execution"""
    def wrapper(self, *args, **kwargs):
        self.log(f"Starting {func.__name__}")
        result = func(self, *args, **kwargs)
        self.log(f"Completed {func.__name__}")
        return result
    return wrapper

class EnhancedAgent(Agent):
    @log_execution
    def price(self, description: str) -> float:
        # Method execution automatically logged
        return self.calculate_price(description)
\end{lstlisting}

\paragraph{Decorator Benefits}
\begin{itemize}
\item \textbf{Separation of Concerns}: Keep core logic separate from cross-cutting concerns
\item \textbf{Reusability}: Same decorator can be applied to multiple functions
\item \textbf{Clean Code}: Avoid repetitive boilerplate code
\item \textbf{Flexibility}: Add/remove behavior without modifying original functions
\end{itemize}

\subsection{Context Managers}

\paragraph{Concept Explanation}
Context managers provide a way to allocate and release resources precisely when needed, typically using the \texttt{with} statement.

\paragraph{Simple Example}
\begin{lstlisting}[caption=Context Manager Examples]
# Built-in context manager for file handling
with open('data.txt', 'r') as file:
    content = file.read()
    # File automatically closed when leaving with block

# Custom context manager
class Timer:
    def __enter__(self):
        import time
        self.start = time.time()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        import time
        self.end = time.time()
        print(f"Elapsed: {self.end - self.start:.2f} seconds")

# Usage
with Timer():
    # Code to time
    sum(range(1000000))

# Using contextlib
from contextlib import contextmanager

@contextmanager
def database_transaction():
    print("Starting transaction")
    try:
        yield "connection"
        print("Committing transaction")
    except Exception:
        print("Rolling back transaction")
        raise
    finally:
        print("Cleaning up")

with database_transaction() as conn:
    # Database operations here
    pass
\end{lstlisting}

\paragraph{System Implementation}
\begin{lstlisting}[caption=Context Managers in Agent System (Potential)]
# The system could benefit from context managers for:

class AgentContext:
    """Context manager for agent lifecycle"""
    def __init__(self, agent_class, *args, **kwargs):
        self.agent_class = agent_class
        self.args = args
        self.kwargs = kwargs
        self.agent = None
    
    def __enter__(self):
        self.agent = self.agent_class(*self.args, **self.kwargs)
        self.agent.log("Agent context started")
        return self.agent
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.agent:
            self.agent.log("Agent context ending")
        # Cleanup resources if needed

# Usage
with AgentContext(FrontierAgent, collection) as agent:
    price = agent.price("laptop computer")
    # Agent automatically cleaned up

# HTTP connection context manager
class HTTPConnection:
    def __init__(self, host, port=443):
        self.host = host
        self.port = port
        self.conn = None
    
    def __enter__(self):
        import http.client
        self.conn = http.client.HTTPSConnection(f"{self.host}:{self.port}")
        return self.conn
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.conn:
            self.conn.close()

# Enhanced MessagingAgent with context manager
class EnhancedMessagingAgent(Agent):
    def push(self, text):
        with HTTPConnection("api.pushover.net") as conn:
            data = urllib.parse.urlencode({
                "token": self.pushover_token,
                "user": self.pushover_user,
                "message": text,
                "sound": "cashregister"
            })
            conn.request("POST", "/1/messages.json", data,
                        {"Content-type": "application/x-www-form-urlencoded"})
            response = conn.getresponse()
            return response.status == 200
\end{lstlisting}

\paragraph{Context Manager Benefits}
\begin{itemize}
\item \textbf{Resource Management}: Automatic cleanup of resources
\item \textbf{Exception Safety}: Cleanup occurs even if exceptions happen
\item \textbf{Clear Intent}: Makes resource lifecycle explicit
\item \textbf{Reduced Errors}: Prevents resource leaks
\end{itemize}

\section{Data Structures and Collections}

\subsection{Dictionaries and Dictionary Operations}

\paragraph{Concept Explanation}
Dictionaries are key-value mappings that provide fast lookups and flexible data storage.

\paragraph{Simple Example}
\begin{lstlisting}[caption=Dictionary Examples]
# Basic dictionary operations
person = {
    'name': 'Alice',
    'age': 30,
    'city': 'New York'
}

# Dictionary access and modification
print(person['name'])        # Alice
person['age'] = 31          # Update existing key
person['job'] = 'Engineer'  # Add new key

# Safe access with get()
email = person.get('email', 'not_provided@example.com')

# Dictionary comprehension
squares = {x: x**2 for x in range(5)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# Merging dictionaries (Python 3.9+)
defaults = {'color': 'blue', 'size': 'medium'}
options = {'color': 'red'}
config = defaults | options  # {'color': 'red', 'size': 'medium'}
\end{lstlisting}

\paragraph{System Implementation}
\begin{lstlisting}[caption=Dictionary Usage in Agent System]
class ScrapedDeal:
    def __init__(self, entry: Dict[str, str]):
        """RSS entry is a dictionary-like object"""
        self.title = entry['title']                    # Dictionary access
        self.summary = extract(entry['summary'])       # Dictionary access
        self.url = entry['links'][0]['href']          # Nested dictionary access
        # ... more processing

class EnsembleAgent(Agent):
    def price(self, description: str) -> float:
        # ... get individual predictions
        
        # Create DataFrame from dictionary
        X = pd.DataFrame({
            'Specialist': [specialist],
            'Frontier': [frontier],
            'RandomForest': [random_forest],
            'Min': [min(specialist, frontier, random_forest)],
            'Max': [max(specialist, frontier, random_forest)],
        })
        return max(0, self.model.predict(X)[0])

class MessagingAgent(Agent):
    def push(self, text):
        # Dictionary for POST data
        data = urllib.parse.urlencode({
            "token": self.pushover_token,
            "user": self.pushover_user,
            "message": text,
            "sound": "cashregister"
        })
        # ... send request

class FrontierAgent(Agent):
    def messages_for(self, description: str, similars: List[str], prices: List[float]) -> List[Dict[str, str]]:
        """Create OpenAI message format (list of dictionaries)"""
        return [
            {"role": "system", "content": system_message},
            {"role": "user", "content": user_prompt},
            {"role": "assistant", "content": "Price is $"}
        ]

    def find_similars(self, description: str):
        results = self.collection.query(...)
        # Access nested dictionary structure
        documents = results['documents'][0][:]
        prices = [m['price'] for m in results['metadatas'][0][:]]
        return documents, prices
\end{lstlisting}

\paragraph{Dictionary Patterns in System}
\begin{itemize}
\item \textbf{Configuration Data}: RSS entries, API parameters
\item \textbf{Structured Data}: DataFrame construction, message formats
\item \textbf{Nested Access}: Multi-level dictionary navigation
\item \textbf{Safe Access}: Using get() method with defaults
\end{itemize}

\subsection{Lists and List Operations}

\paragraph{Concept Explanation}
Lists are ordered, mutable sequences that can contain any type of objects.

\paragraph{Simple Example}
\begin{lstlisting}[caption=List Examples]
# Basic list operations
numbers = [1, 2, 3, 4, 5]
numbers.append(6)           # Add to end: [1, 2, 3, 4, 5, 6]
numbers.insert(0, 0)        # Insert at position: [0, 1, 2, 3, 4, 5, 6]
numbers.remove(3)           # Remove first occurrence: [0, 1, 2, 4, 5, 6]

# List slicing
first_three = numbers[:3]   # [0, 1, 2]
last_two = numbers[-2:]     # [5, 6]
every_second = numbers[::2] # [0, 2, 5]

# List methods
numbers.sort()              # In-place sorting
numbers.reverse()           # In-place reversal
count = numbers.count(2)    # Count occurrences

# List unpacking
a, b, *rest = [1, 2, 3, 4, 5]  # a=1, b=2, rest=[3, 4, 5]
\end{lstlisting}

\paragraph{System Implementation}
\begin{lstlisting}[caption=List Usage in Agent System]
# Module-level list configuration
feeds = [
    "https://www.dealnews.com/c142/Electronics/?rss=1",
    "https://www.dealnews.com/c39/Computers/?rss=1",
    "https://www.dealnews.com/c238/Automotive/?rss=1",
    "https://www.dealnews.com/f1912/Smart-Home/?rss=1",
    "https://www.dealnews.com/c196/Home-Garden/?rss=1",
]

class ScrapedDeal:
    @classmethod
    def fetch(cls, show_progress: bool = False) -> List[Self]:
        deals = []  # Initialize empty list
        for feed_url in feeds:
            feed = feedparser.parse(feed_url)
            # List slicing to limit entries
            for entry in feed.entries[:10]:
                deals.append(cls(entry))  # List append
        return deals

class PlanningAgent(Agent):
    def plan(self, memory: List[str] = []) -> Optional[Opportunity]:
        selection = self.scanner.scan(memory=memory)
        if selection:
            # List comprehension + slicing
            opportunities = [self.run(deal) for deal in selection.deals[:5]]
            # In-place sorting with custom key
            opportunities.sort(key=lambda opp: opp.discount, reverse=True)
            best = opportunities[0]  # List indexing
            return best if best.discount > self.DEAL_THRESHOLD else None
        return None

class ScannerAgent(Agent):
    def fetch_deals(self, memory) -> List[ScrapedDeal]:
        # List comprehension for URL extraction
        urls = [opp.deal.url for opp in memory]
        scraped = ScrapedDeal.fetch()
        # List comprehension with filtering
        result = [scrape for scrape in scraped if scrape.url not in urls]
        return result

class FrontierAgent(Agent):
    def find_similars(self, description: str):
        # Single-item list for encoding
        vector = self.model.encode([description])
        results = self.collection.query(query_embeddings=vector.astype(float).tolist(), n_results=5)
        # List access and slicing
        documents = results['documents'][0][:]
        # List comprehension for data extraction
        prices = [m['price'] for m in results['metadatas'][0][:]]
        return documents, prices
\end{lstlisting}

\paragraph{List Patterns in System}
\begin{itemize}
\item \textbf{Configuration}: Module-level feed URLs
\item \textbf{Collection Building}: Accumulating results with append()
\item \textbf{Data Processing}: Slicing, sorting, filtering
\item \textbf{Comprehensions}: Concise data transformations
\end{itemize}

\section{Exception Handling}

\paragraph{Concept Explanation}
Exception handling allows programs to respond gracefully to errors and unexpected conditions.

\paragraph{Simple Example}
\begin{lstlisting}[caption=Exception Handling Examples]
# Basic try-except
try:
    result = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero")
    result = None

# Multiple exception types
try:
    data = {'key': 'value'}
    value = data['missing_key']
    number = int(value)
except KeyError:
    print("Key not found")
except ValueError:
    print("Invalid number format")
except Exception as e:
    print(f"Unexpected error: {e}")

# Try-except-else-finally
try:
    file = open('data.txt', 'r')
except FileNotFoundError:
    print("File not found")
else:
    # Runs only if no exception occurred
    content = file.read()
    print(f"Read {len(content)} characters")
finally:
    # Always runs
    if 'file' in locals():
        file.close()

# Custom exceptions
class ValidationError(Exception):
    def __init__(self, message, code=None):
        super().__init__(message)
        self.code = code

def validate_price(price):
    if price < 0:
        raise ValidationError("Price cannot be negative", code="NEGATIVE_PRICE")
    return price
\end{lstlisting}

\paragraph{System Implementation}
\begin{lstlisting}[caption=Exception Handling in Agent System (Current and Potential)]
# Current system has limited exception handling
# Here's what exists and what could be improved:

class FrontierAgent(Agent):
    def price(self, description: str) -> float:
        """Current implementation lacks error handling"""
        documents, prices = self.find_similars(description)
        response = self.client.chat.completions.create(
            model=self.MODEL, 
            messages=self.messages_for(description, documents, prices),
            seed=42,
            max_tokens=5
        )
        reply = response.choices[0].message.content
        result = self.get_price(reply)
        return result

# Enhanced version with proper exception handling
class EnhancedFrontierAgent(Agent):
    def price(self, description: str) -> float:
        try:
            documents, prices = self.find_similars(description)
        except Exception as e:
            self.log(f"Error finding similar products: {e}")
            return 0.0  # Fallback price
        
        try:
            response = self.client.chat.completions.create(
                model=self.MODEL, 
                messages=self.messages_for(description, documents, prices),
                seed=42,
                max_tokens=5,
                timeout=30  # Add timeout
            )
        except (openai.APIError, openai.RateLimitError, openai.Timeout) as e:
            self.log(f"OpenAI API error: {e}")
            return 0.0  # Fallback price
        except Exception as e:
            self.log(f"Unexpected error calling LLM: {e}")
            return 0.0
        
        try:
            reply = response.choices[0].message.content
            result = self.get_price(reply)
            if result <= 0:
                self.log("Invalid price prediction, using fallback")
                return 0.0
            return result
        except (IndexError, AttributeError) as e:
            self.log(f"Error processing LLM response: {e}")
            return 0.0

class EnhancedMessagingAgent(Agent):
    def push(self, text):
        """Enhanced version with proper error handling"""
        try:
            conn = http.client.HTTPSConnection("api.pushover.net:443", timeout=10)
            data = urllib.parse.urlencode({
                "token": self.pushover_token,
                "user": self.pushover_user,
                "message": text,
                "sound": "cashregister"
            })
            
            conn.request("POST", "/1/messages.json", data,
                        {"Content-type": "application/x-www-form-urlencoded"})
            response = conn.getresponse()
            
            if response.status == 200:
                self.log("Push notification sent successfully")
                return True
            else:
                self.log(f"Push notification failed: {response.status} {response.reason}")
                return False
                
        except (http.client.HTTPException, OSError, TimeoutError) as e:
            self.log(f"Network error sending push notification: {e}")
            return False
        except Exception as e:
            self.log(f"Unexpected error sending push notification: {e}")
            return False
        finally:
            try:
                conn.close()
            except:
                pass  # Ignore cleanup errors
\end{lstlisting}

\paragraph{Exception Handling Benefits}
\begin{itemize}
\item \textbf{Robustness}: System continues operation despite errors
\item \textbf{User Experience}: Graceful degradation instead of crashes
\item \textbf{Debugging}: Better error messages and logging
\item \textbf{Resource Management}: Proper cleanup in error conditions
\end{itemize}

\section{Functional Programming Concepts}

\subsection{Lambda Functions}

\paragraph{Concept Explanation}
Lambda functions are anonymous functions that can be defined inline, often used for short operations.

\paragraph{Simple Example}
\begin{lstlisting}[caption=Lambda Function Examples]
# Basic lambda functions
square = lambda x: x**2
print(square(5))  # 25

# Lambda with multiple parameters
add = lambda x, y: x + y
print(add(3, 4))  # 7

# Lambda in higher-order functions
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))  # [1, 4, 9, 16, 25]
evens = list(filter(lambda x: x % 2 == 0, numbers))  # [2, 4]

# Lambda for sorting
students = [('Alice', 85), ('Bob', 90), ('Charlie', 78)]
students.sort(key=lambda student: student[1])  # Sort by grade

# Lambda with conditional
grade = lambda score: 'A' if score >= 90 else 'B' if score >= 80 else 'C'
\end{lstlisting}

\paragraph{System Implementation}
\begin{lstlisting}[caption=Lambda Functions in Agent System]
class PlanningAgent(Agent):
    def plan(self, memory: List[str] = []) -> Optional[Opportunity]:
        selection = self.scanner.scan(memory=memory)
        if selection:
            opportunities = [self.run(deal) for deal in selection.deals[:5]]
            # Lambda function for sorting by discount (descending)
            opportunities.sort(key=lambda opp: opp.discount, reverse=True)
            best = opportunities[0]
            self.log(f"Planning Agent has identified the best deal has discount ${best.discount:.2f}")
            if best.discount > self.DEAL_THRESHOLD:
                self.messenger.alert(best)
            return best if best.discount > self.DEAL_THRESHOLD else None
        return None

# Additional lambda usage patterns in the system
class DataProcessor:
    def filter_deals(self, deals: List[ScrapedDeal]) -> List[ScrapedDeal]:
        """Filter deals based on various criteria"""
        # Filter by title length
        good_titles = list(filter(lambda deal: len(deal.title) > 10, deals))
        
        # Sort by URL length (just an example)
        good_titles.sort(key=lambda deal: len(deal.url))
        
        return good_titles
    
    def transform_prices(self, opportunities: List[Opportunity]) -> List[float]:
        """Extract and transform price data"""
        # Extract discounts using lambda
        discounts = list(map(lambda opp: opp.discount, opportunities))
        
        # Calculate relative discounts
        relative = list(map(lambda opp: opp.discount / opp.estimate if opp.estimate > 0 else 0, opportunities))
        
        return relative
\end{lstlisting}

\paragraph{Lambda Benefits in System}
\begin{itemize}
\item \textbf{Conciseness}: Short inline functions for simple operations
\item \textbf{Readability}: Clear intent for sorting and filtering
\item \textbf{Functional Style}: Works well with map(), filter(), sort()
\item \textbf{No Namespace Pollution}: No need to define named functions
\end{itemize}

\section{File I/O and Serialization}

\paragraph{Concept Explanation}
File operations and object serialization for data persistence and configuration.

\paragraph{Simple Example}
\begin{lstlisting}[caption=File I/O and Serialization Examples]
import json
import pickle
import joblib

# JSON serialization
data = {
    'name': 'Alice',
    'scores': [85, 90, 78],
    'active': True
}

# Write JSON
with open('data.json', 'w') as f:
    json.dump(data, f, indent=2)

# Read JSON
with open('data.json', 'r') as f:
    loaded_data = json.load(f)

# Pickle serialization (Python objects)
complex_object = {'function': lambda x: x*2, 'data': [1, 2, 3]}

with open('object.pkl', 'wb') as f:
    pickle.dump(complex_object, f)

with open('object.pkl', 'rb') as f:
    loaded_object = pickle.load(f)

# Joblib for ML models (optimized for numpy arrays)
from sklearn.linear_model import LinearRegression
import numpy as np

# Train and save model
X = np.array([[1], [2], [3], [4]])
y = np.array([2, 4, 6, 8])
model = LinearRegression().fit(X, y)

joblib.dump(model, 'model.pkl')
loaded_model = joblib.load('model.pkl')
\end{lstlisting}

\paragraph{System Implementation}
\begin{lstlisting}[caption=Serialization in Agent System]
class EnsembleAgent(Agent):
    def __init__(self, collection):
        self.log("Initializing Ensemble Agent")
        self.specialist = SpecialistAgent()
        self.frontier = FrontierAgent(collection)
        self.random_forest = RandomForestAgent()
        # Load pre-trained ensemble model using joblib
        self.model = joblib.load('ensemble_model.pkl')
        self.log("Ensemble Agent is ready")

class RandomForestAgent(Agent):
    def __init__(self):
        self.log("Random Forest Agent is initializing")
        self.vectorizer = SentenceTransformer('sentence-transformers/all-MiniLM-L6-v2')
        # Load pre-trained Random Forest model
        self.model = joblib.load('random_forest_model.pkl')
        self.log("Random Forest Agent is ready")

# Environment variable loading (configuration)
import os
from dotenv import load_dotenv  # In scanner_agent_langchain.py

load_dotenv(override=True)
os.environ['GOOGLE_API_KEY'] = os.getenv("GOOGLE_API_KEY_1")

class MessagingAgent(Agent):
    def __init__(self):
        # Load configuration from environment variables
        if DO_TEXT:
            account_sid = os.getenv('TWILIO_ACCOUNT_SID', 'fallback-value')
            auth_token = os.getenv('TWILIO_AUTH_TOKEN', 'fallback-value')
            self.me_from = os.getenv('TWILIO_FROM', 'fallback-value')
            self.me_to = os.getenv('MY_PHONE_NUMBER', 'fallback-value')
        
        if DO_PUSH:
            self.pushover_user = os.getenv('PUSHOVER_USER', 'fallback-value')
            self.pushover_token = os.getenv('PUSHOVER_TOKEN', 'fallback-value')

# Potential enhancement: Configuration file management
class ConfigManager:
    @staticmethod
    def load_config(config_path: str = 'config.json') -> dict:
        """Load system configuration from JSON file"""
        try:
            with open(config_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return ConfigManager.default_config()
    
    @staticmethod
    def save_config(config: dict, config_path: str = 'config.json'):
        """Save system configuration to JSON file"""
        with open(config_path, 'w') as f:
            json.dump(config, f, indent=2)
    
    @staticmethod
    def default_config() -> dict:
        return {
            'deal_threshold': 50,
            'max_deals_per_run': 5,
            'feeds': [
                "https://www.dealnews.com/c142/Electronics/?rss=1",
                # ... other feeds
            ],
            'notification_settings': {
                'enable_push': True,
                'enable_sms': False,
                'sound': 'cashregister'
            }
        }
\end{lstlisting}

\paragraph{Serialization Benefits in System}
\begin{itemize}
\item \textbf{Model Persistence}: Trained ML models saved and loaded
\item \textbf{Configuration}: Environment variables for secure config
\item \textbf{State Management}: Could save/restore agent states
\item \textbf{Data Exchange}: JSON for structured data interchange
\end{itemize}

\section{Chapter Summary}

This chapter covered the extensive range of Python concepts utilized in the multi-agent system:

\subsection{Core OOP Concepts}
\begin{itemize}
\item \textbf{Classes and Objects}: Agent hierarchy with specialized behaviors
\item \textbf{Inheritance}: Code reuse through Agent base class
\item \textbf{Composition}: Complex agents built from simpler components
\item \textbf{Polymorphism}: Interchangeable agents with common interfaces
\end{itemize}

\subsection{Modern Python Features}
\begin{itemize}
\item \textbf{Type Annotations}: Improved code documentation and IDE support
\item \textbf{F-Strings}: Readable string formatting and interpolation
\item \textbf{List Comprehensions}: Concise data transformations
\item \textbf{Context Managers}: Resource management best practices
\end{itemize}

\subsection{Advanced Concepts}
\begin{itemize}
\item \textbf{Decorators}: Method modification and enhancement
\item \textbf{Exception Handling}: Robust error management
\item \textbf{Lambda Functions}: Inline functions for simple operations
\item \textbf{File I/O}: Data persistence and configuration management
\end{itemize}

\subsection{Data Structures}
\begin{itemize}
\item \textbf{Dictionaries}: Configuration, API data, structured information
\item \textbf{Lists}: Collections, results, processing pipelines
\item \textbf{Tuples}: Return multiple values, immutable data
\item \textbf{Sets}: Unique collections, membership testing
\end{itemize}

Each concept is demonstrated with both simple examples for learning and real implementations from the agent system, showing how fundamental Python features combine to create sophisticated, production-ready applications. The system exemplifies best practices in Python programming while solving complex real-world problems in automated deal discovery and machine learning integration.